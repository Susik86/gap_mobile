{"content": {"suites": {"0": {"status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 2}, "tests": {"0": {"status": "ERROR", "message": "@pytest.fixture(scope=\"session\", autouse=True)\n    def appium_server():\n        \"\"\"Start Appium server before the test session and stop after all tests.\"\"\"\n        logger = logging.getLogger(\"mobile_framework_logger\")\n        logger.info(\"\ud83d\ude80 Starting Appium server before the session...\")\n    \n>       start_appium_server()  # \u2705 Start Appium server\n\nconftest.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nutils/appium_server.py:36: in start_appium_server\n    appium_service.start(args=[\"--port\", \"4723\", \"--base-path\", \"/wd/hub\"])\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <appium.webdriver.appium_service.AppiumService object at 0x7fcc949d45b0>, kwargs = {'args': ['--port', '4723', '--base-path', '/wd/hub']}, env = None\nnode = '/usr/local/bin/node', npm = '/usr/local/bin/npm', main_script = '/usr/local/lib/node_modules/appium/build/lib/main.js', default_std = -1, stdout = -1\nstderr = -1\n\n    def start(self, **kwargs: Any) -> sp.Popen:\n        \"\"\"Starts Appium service with given arguments.\n    \n        If you use the service to start Appium 1.x\n        then consider providing ['--base-path', '/wd/hub'] arguments. By default,\n        the service assumes Appium server listens on '/' path, which is the default path\n        for Appium 2.\n    \n        The service will be forcefully restarted if it is already running.\n    \n        Keyword Args:\n            env (dict): Environment variables mapping. The default system environment,\n                which is inherited from the parent process, is assigned by default.\n            node (str): The full path to the main NodeJS executable. The service will try\n                to retrieve it automatically if not provided.\n            npm (str): The full path to the Node Package Manager (npm) script. The service will try\n                to retrieve it automatically if not provided.\n            stdout (int): Check the documentation for subprocess.Popen for more details.\n                The default value is subprocess.DEVNULL on Windows and subprocess.PIPE on other platforms.\n            stderr (int): Check the documentation for subprocess.Popen for more details.\n                The default value is subprocess.DEVNULL on Windows and subprocess.PIPE on other platforms.\n            timeout_ms (int): The maximum time to wait until Appium process starts listening\n                for HTTP connections. If set to zero or a negative number then no wait will be applied.\n                60000 ms by default.\n            main_script (str): The full path to the main Appium executable\n                (usually located at build/lib/main.js). If not set\n                then the service tries to detect the path automatically.\n            args (str): List of Appium arguments (all must be strings). Check\n                https://appium.io/docs/en/writing-running-appium/server-args/ for more details\n                about possible arguments and their values.\n    \n        :return: You can use Popen.communicate interface or stderr/stdout properties\n            of the instance (stdout/stderr must not be set to None in such case) in order to retrieve the actual process\n            output.\n        \"\"\"\n        self.stop()\n    \n        env = kwargs['env'] if 'env' in kwargs else None\n        node: str = kwargs.get('node') or get_node()\n        npm: str = kwargs.get('npm') or get_npm()\n        main_script: str = kwargs.get('main_script') or get_main_script(node, npm)\n        # A workaround for https://github.com/appium/python-client/issues/534\n        default_std = sp.DEVNULL if sys.platform == 'win32' else sp.PIPE\n        stdout = kwargs['stdout'] if 'stdout' in kwargs else default_std\n        stderr = kwargs['stderr'] if 'stderr' in kwargs else default_std\n        timeout_ms = int(kwargs['timeout_ms']) if 'timeout_ms' in kwargs else STARTUP_TIMEOUT_MS\n        args: List[str] = [node, main_script]\n        if 'args' in kwargs:\n            args.extend(kwargs['args'])\n        self._cmd = args\n        self._process = sp.Popen(args=args, stdout=stdout, stderr=stderr, env=env)\n        error_msg: Optional[str] = None\n        startup_failure_msg = (\n            'Appium server process is unable to start. Make sure proper values have been '\n            f\"provided to 'node' ({node}), 'npm' ({npm}) and 'main_script' ({main_script}) \"\n            f'method arguments.'\n        )\n        if timeout_ms > 0:\n            server_url = _make_server_url(args)\n            try:\n                if not is_service_listening(\n                    server_url,\n                    timeout=timeout_ms / 1000,\n                    custom_validator=self._assert_is_running,\n                ):\n                    error_msg = (\n                        f'Appium server has started but is not listening on {server_url} '\n                        f'within {timeout_ms}ms timeout. Make sure proper values have been provided '\n                        f'to --base-path, --address and --port process arguments.'\n                    )\n            except AppiumStartupError:\n                error_msg = startup_failure_msg\n        elif not self.is_running:\n            error_msg = startup_failure_msg\n        if error_msg is not None:\n            if stderr == sp.PIPE and self._process.stderr is not None:\n                # noinspection PyUnresolvedReferences\n                err_output = self._process.stderr.read()\n                if err_output:\n                    error_msg += f'\\nOriginal error: {str(err_output)}'\n            self.stop()\n>           raise AppiumServiceError(error_msg)\nE           appium.webdriver.appium_service.AppiumServiceError: Appium server process is unable to start. Make sure proper values have been provided to 'node' (/usr/local/bin/node), 'npm' (/usr/local/bin/npm) and 'main_script' (/usr/local/lib/node_modules/appium/build/lib/main.js) method arguments.\nE           Original error: b\"\\x1b[38;5;86m[HTTP]\\x1b[0m Could not start REST http interface listener. The requested port may already be in use. Please make sure there is no other instance of this server running already.\\n\\x1b[38;5;112m[Appium]\\x1b[0m Could not configure Appium server. It's possible that a driver or plugin tried to update the server and failed. Original error: listen EADDRINUSE: address already in use 0.0.0.0:4723\\n\"\n\n../Library/Python/3.8/lib/python/site-packages/appium/webdriver/appium_service.py:128: AppiumServiceError\n", "test_name": "test_invalid_login_pop_up", "rerun": "0"}, "1": {"status": "ERROR", "message": "@pytest.fixture(scope=\"session\", autouse=True)\n    def appium_server():\n        \"\"\"Start Appium server before the test session and stop after all tests.\"\"\"\n        logger = logging.getLogger(\"mobile_framework_logger\")\n        logger.info(\"\ud83d\ude80 Starting Appium server before the session...\")\n    \n>       start_appium_server()  # \u2705 Start Appium server\n\nconftest.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nutils/appium_server.py:36: in start_appium_server\n    appium_service.start(args=[\"--port\", \"4723\", \"--base-path\", \"/wd/hub\"])\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <appium.webdriver.appium_service.AppiumService object at 0x7fcc949d45b0>, kwargs = {'args': ['--port', '4723', '--base-path', '/wd/hub']}, env = None\nnode = '/usr/local/bin/node', npm = '/usr/local/bin/npm', main_script = '/usr/local/lib/node_modules/appium/build/lib/main.js', default_std = -1, stdout = -1\nstderr = -1\n\n    def start(self, **kwargs: Any) -> sp.Popen:\n        \"\"\"Starts Appium service with given arguments.\n    \n        If you use the service to start Appium 1.x\n        then consider providing ['--base-path', '/wd/hub'] arguments. By default,\n        the service assumes Appium server listens on '/' path, which is the default path\n        for Appium 2.\n    \n        The service will be forcefully restarted if it is already running.\n    \n        Keyword Args:\n            env (dict): Environment variables mapping. The default system environment,\n                which is inherited from the parent process, is assigned by default.\n            node (str): The full path to the main NodeJS executable. The service will try\n                to retrieve it automatically if not provided.\n            npm (str): The full path to the Node Package Manager (npm) script. The service will try\n                to retrieve it automatically if not provided.\n            stdout (int): Check the documentation for subprocess.Popen for more details.\n                The default value is subprocess.DEVNULL on Windows and subprocess.PIPE on other platforms.\n            stderr (int): Check the documentation for subprocess.Popen for more details.\n                The default value is subprocess.DEVNULL on Windows and subprocess.PIPE on other platforms.\n            timeout_ms (int): The maximum time to wait until Appium process starts listening\n                for HTTP connections. If set to zero or a negative number then no wait will be applied.\n                60000 ms by default.\n            main_script (str): The full path to the main Appium executable\n                (usually located at build/lib/main.js). If not set\n                then the service tries to detect the path automatically.\n            args (str): List of Appium arguments (all must be strings). Check\n                https://appium.io/docs/en/writing-running-appium/server-args/ for more details\n                about possible arguments and their values.\n    \n        :return: You can use Popen.communicate interface or stderr/stdout properties\n            of the instance (stdout/stderr must not be set to None in such case) in order to retrieve the actual process\n            output.\n        \"\"\"\n        self.stop()\n    \n        env = kwargs['env'] if 'env' in kwargs else None\n        node: str = kwargs.get('node') or get_node()\n        npm: str = kwargs.get('npm') or get_npm()\n        main_script: str = kwargs.get('main_script') or get_main_script(node, npm)\n        # A workaround for https://github.com/appium/python-client/issues/534\n        default_std = sp.DEVNULL if sys.platform == 'win32' else sp.PIPE\n        stdout = kwargs['stdout'] if 'stdout' in kwargs else default_std\n        stderr = kwargs['stderr'] if 'stderr' in kwargs else default_std\n        timeout_ms = int(kwargs['timeout_ms']) if 'timeout_ms' in kwargs else STARTUP_TIMEOUT_MS\n        args: List[str] = [node, main_script]\n        if 'args' in kwargs:\n            args.extend(kwargs['args'])\n        self._cmd = args\n        self._process = sp.Popen(args=args, stdout=stdout, stderr=stderr, env=env)\n        error_msg: Optional[str] = None\n        startup_failure_msg = (\n            'Appium server process is unable to start. Make sure proper values have been '\n            f\"provided to 'node' ({node}), 'npm' ({npm}) and 'main_script' ({main_script}) \"\n            f'method arguments.'\n        )\n        if timeout_ms > 0:\n            server_url = _make_server_url(args)\n            try:\n                if not is_service_listening(\n                    server_url,\n                    timeout=timeout_ms / 1000,\n                    custom_validator=self._assert_is_running,\n                ):\n                    error_msg = (\n                        f'Appium server has started but is not listening on {server_url} '\n                        f'within {timeout_ms}ms timeout. Make sure proper values have been provided '\n                        f'to --base-path, --address and --port process arguments.'\n                    )\n            except AppiumStartupError:\n                error_msg = startup_failure_msg\n        elif not self.is_running:\n            error_msg = startup_failure_msg\n        if error_msg is not None:\n            if stderr == sp.PIPE and self._process.stderr is not None:\n                # noinspection PyUnresolvedReferences\n                err_output = self._process.stderr.read()\n                if err_output:\n                    error_msg += f'\\nOriginal error: {str(err_output)}'\n            self.stop()\n>           raise AppiumServiceError(error_msg)\nE           appium.webdriver.appium_service.AppiumServiceError: Appium server process is unable to start. Make sure proper values have been provided to 'node' (/usr/local/bin/node), 'npm' (/usr/local/bin/npm) and 'main_script' (/usr/local/lib/node_modules/appium/build/lib/main.js) method arguments.\nE           Original error: b\"\\x1b[38;5;86m[HTTP]\\x1b[0m Could not start REST http interface listener. The requested port may already be in use. Please make sure there is no other instance of this server running already.\\n\\x1b[38;5;112m[Appium]\\x1b[0m Could not configure Appium server. It's possible that a driver or plugin tried to update the server and failed. Original error: listen EADDRINUSE: address already in use 0.0.0.0:4723\\n\"\n\n../Library/Python/3.8/lib/python/site-packages/appium/webdriver/appium_service.py:128: AppiumServiceError\n", "test_name": "test_valid_login", "rerun": "0"}}, "suite_name": "tests/test_login.py"}}}, "date": "March 03, 2025", "start_time": 1740984425.466805, "total_suite": 1, "status": "FAIL", "status_list": {"pass": "0", "fail": "0", "skip": "0", "error": "2", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "2"}